import ui
import photos
import motion
import numpy as np
import time
import io
from PIL import Image
import sympy as sp

# ====== æ‹ç…§ + é‡åŠ›è·å– ======
def capture_image_and_gravity():
    print("ğŸ“· è¯·ä¿æŒæ‰‹æœºç¨³å®šï¼Œå‡†å¤‡æ‹ç…§...")
    motion.start_updates()
    time.sleep(1.0)
    img = photos.capture_image()
    gravity = motion.get_gravity()
    motion.stop_updates()

    g = np.array(gravity)
    
    # âœ… è‡ªåŠ¨ä¿®æ­£ gy åˆ†é‡æ–¹å‘
    if g[1] < 0:
        g[1] = -g[1]
        print("ğŸ”„ è‡ªåŠ¨åè½¬ gy åˆ†é‡ï¼ˆé‡åŠ›æ–¹å‘å‘ä¸Šå·²ä¿®æ­£ä¸ºå‘ä¸‹ï¼‰")
        
    g /= np.linalg.norm(g)
    print("âœ… è·å–é‡åŠ›å‘é‡:", g)
    return img, g

# ====== å›¾åƒç‚¹å‡»é€‰ç‚¹ ======
def select_points(pil_img, num_points=4):
    image_data = io.BytesIO()
    pil_img.save(image_data, format='PNG')
    ui_img = ui.Image.from_data(image_data.getvalue())

    w, h = pil_img.size
    selected_points = []

    def on_touch(sender, touch):
        if len(selected_points) < num_points:
            loc = touch.location
            print(f"ğŸ“ ç‚¹å‡»ç‚¹ï¼š{loc}")
            selected_points.append(loc)
        if len(selected_points) >= num_points:
            sender.close()

    class TouchView(ui.View):
        def __init__(self):
            self.bg_color = 'white'
            self.frame = (0, 0, w, h)
            self.name = f"ç‚¹å‡» {num_points} ä¸ªç‚¹"
            iv = ui.ImageView(frame=(0, 0, w, h))
            iv.image = ui_img
            iv.flex = 'WH'
            self.add_subview(iv)

        def touch_ended(self, touch):
            on_touch(self, touch)

    v = TouchView()
    v.present('sheet')
    while len(selected_points) < num_points:
        time.sleep(0.2)
    return selected_points

# ====== æ•°å­¦å‡½æ•° ======
def Function_F(gravity, firstPoint, secondPoint, focalLength):
    gx, gy, gz = gravity
    px, py = firstPoint
    pxp, pyp = secondPoint
    f = focalLength

    A = (gx**2 + gz**2)*(px - pxp)**2 + (gy**2 + gz**2)*(py - pyp)**2 + 2*gx*gy*(pxp - px)*(pyp - py)
    B = 2*gz*(pxp*py - px*pyp)*(gy*(px - pxp) + gx*(pyp - py))
    C = (gx**2 + gy**2)*(pxp*py - px*pyp)**2
    D = gz**2
    E = -(gx*gz*pxp + gy*gz*pyp + gx*gz*px + gy*gz*py)
    F_term = gx**2*px*py + gx*gy*pxp*py + gx*gy*px*pyp + gy**2*py*pyp

    numerator = sp.sqrt(A * f**2 + B * f + C)
    denominator = sp.Abs(D * f**2 + E * f + F_term)
    return numerator / denominator

def calibrate_focal_length(gravity, points, L1, L2, image_width):
    f = sp.symbols('f')
    p1, p2 = points[0], points[1]
    q1, q2 = points[2], points[3]

    F1 = Function_F(gravity, p1, p2, f)
    F2 = Function_F(gravity, q1, q2, f)
    equation = (F1 / F2) - (L1 / L2)

    f_guesses = [image_width / (2 * np.tan(np.deg2rad(60) / 2)), 800, 1000, 1200, 1500]
    for guess in f_guesses:
        try:
            res = float(sp.nsolve(equation, f, guess))
            print(f"âœ… ä½¿ç”¨åˆå§‹å€¼ {guess:.1f} æˆåŠŸæ±‚è§£ç„¦è·: {res:.2f}")
            return res
        except Exception as e:
            print(f"âš ï¸ åˆå§‹å€¼ {guess:.1f} æ±‚è§£å¤±è´¥: {e}")
    raise ValueError("âŒ æ‰€æœ‰åˆå§‹å€¼éƒ½å¤±è´¥ï¼Œè¯·é‡æ–°é€‰æ‹©ç‚¹æˆ–è¾“å…¥çœŸå®é•¿åº¦")

def computeMagnificationRatio(gravity, startPoint, endPoint, length, focalLength, para_d=0):
    gz = gravity[2]
    f = focalLength
    Lpp = length
    s = abs(para_d + f * gz)
    F = Function_F(gravity, startPoint, endPoint, f)
    ratio = Lpp / s / F
    return ratio

# ====== ä¸»æµç¨‹ ======
def main():
    pil_img, gravity = capture_image_and_gravity()
    img_np = np.array(pil_img)
    h, w = img_np.shape[:2]
    center = np.array([w / 2, h / 2])

    print("\nğŸ‘‰ è¯·ä¾æ¬¡ç‚¹å‡»ä¸¤å¯¹å‚è€ƒç‚¹ï¼ˆå…± 4 ä¸ªï¼‰")
    points = select_points(pil_img, num_points=4)
    points = np.array(points) - center

    L1 = float(input("è¯·è¾“å…¥ç¬¬ä¸€ä¸ªå·²çŸ¥é•¿åº¦ (cm)ï¼š"))
    L2 = float(input("è¯·è¾“å…¥ç¬¬äºŒä¸ªå·²çŸ¥é•¿åº¦ (cm)ï¼š"))

    f = calibrate_focal_length(gravity, points, L1, L2, image_width=w)
    print(f"\nğŸ“ ç„¦è·ä¼°è®¡å€¼ï¼š{f:.2f} åƒç´ ")

    e = computeMagnificationRatio(gravity, points[0], points[1], L1, f)
    print(f"ğŸ” æ”¾å¤§æ¯”ä¾‹ï¼š{e:.5f} cm/åƒç´ ")

    print("\nğŸ“ è¯·ç‚¹å‡»ä¸¤ä¸ªæµ‹é‡ç‚¹")
    mpoints = select_points(pil_img, num_points=2)
    mpoints = np.array(mpoints) - center

    F_val = Function_F(gravity, mpoints[0], mpoints[1], f)
    s = abs(f * gravity[2])
    distance = e * s * F_val
    print(f"\nâœ… æµ‹é‡ç»“æœï¼š{distance:.2f} cm")

if __name__ == '__main__':
    main()
